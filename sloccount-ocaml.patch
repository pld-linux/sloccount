diff -ur sloccount-2.21/TODO sloccount-2.21-/TODO
--- sloccount-2.21/TODO	Wed Jan 29 04:05:02 2003
+++ sloccount-2.21-/TODO	Sat Feb 15 21:52:32 2003
@@ -43,9 +43,8 @@
 + .pfo -> Oracle preprocessed Fortran Code
 + PL/1.
 + BASIC, including Visual Basic, Future Basic, GW-Basic, QBASIC, etc.
-+ Improve ML/CAML.  It uses Pascal-style comments (*..*),
-  double-quoted C-like strings "\n...", and .ml or .mli file extensions
-  (.mli is an interface file for CAML).
++ Improve Ocamlyacc, comments in yacc part are C-like, but I'm not sure
+  about comment nesting. 
 
   For more language examples, see the ACM "Hello World" project, which tries
   to collect "Hello World" in every computer language. It's at:
Only in sloccount-2.21-: a.out
diff -ur sloccount-2.21/break_filelist sloccount-2.21-/break_filelist
--- sloccount-2.21/break_filelist	Wed Jan 29 04:05:02 2003
+++ sloccount-2.21-/break_filelist	Sat Feb 15 21:51:54 2003
@@ -178,7 +178,10 @@
   "php6" => "php",
   "inc" => "inc", # inc MAY be PHP - we'll handle it specially.
   "m3" => "modula3", "i3" => "modula3",
-  "ml" => "ml", "mli" => "ml",
+  "ml" => "ml", "mli" => "ml", 
+  "mly" => "ml", # ocamlyacc. In fact this is half-yacc half-ML, especially
+  		 # comments in yacc part are C-like, not ML like.
+  "mll" => "ml", # ocamllex, no such problems as in ocamlyacc
   "rb" => "ruby",
   "hs" => "haskell",
   # Doesn't handle literate Haskell, .lhs.
Only in sloccount-2.21-: c_count
Only in sloccount-2.21-: java_count
Only in sloccount-2.21-: jsp_count
Only in sloccount-2.21-: lexcount1
diff -ur sloccount-2.21/makefile sloccount-2.21-/makefile
--- sloccount-2.21/makefile	Wed Jan 29 04:12:05 2003
+++ sloccount-2.21-/makefile	Sat Feb 15 21:48:00 2003
@@ -63,7 +63,8 @@
    lexcount1$(EXE_SUFFIX) \
    pascal_count$(EXE_SUFFIX) \
    php_count$(EXE_SUFFIX) \
-   jsp_count$(EXE_SUFFIX)
+   jsp_count$(EXE_SUFFIX) \
+   ml_count$(EXE_SUFFIX)
 
 EXECUTABLES= \
    ada_count \
@@ -87,7 +88,6 @@
    lisp_count \
    make_filelists \
    makefile_count \
-   ml_count \
    modula3_count \
    objc_count \
    perl_count \
@@ -130,6 +130,9 @@
 jsp_count$(EXE_SUFFIX): jsp_count.c
 	$(CC) jsp_count.c -o jsp_count$(EXE_SUFFIX)
 
+ml_count$(EXE_SUFFIX): ml_count.c
+	$(CC) ml_count.c -o ml_count$(EXE_SUFFIX)
+
 sloccount.1.gz: sloccount.1
 	gzip -c sloccount.1 > sloccount.1.gz
 
Binary files sloccount-2.21/ml_count and sloccount-2.21-/ml_count differ
diff -ur sloccount-2.21/ml_count.c sloccount-2.21-/ml_count.c
--- sloccount-2.21/ml_count.c	Sat Feb 15 22:04:09 2003
+++ sloccount-2.21-/ml_count.c	Sat Feb 15 22:01:33 2003
@@ -0,0 +1,194 @@
+/* ml_count: given a list of ML files on the command line,
+   count the SLOC in each one.  SLOC = physical, non-comment lines.
+
+   (C) Copyright 2003 Michal Moskal <malekith@pld-linux.org>
+   Covered by the GNU GPL, version 2.
+
+   Based on c_count.c by:
+   (C) Copyright 2000 David A. Wheeler
+   Covered by the GNU GPL, version 2.
+   This is part of "SLOCCount"; see the documentation for details.
+
+   Usage: Use in one of the following ways:
+     ml_count                      # As filter
+     ml_count [-f file] [list_of_files]
+       file: file with a list of files to count (if "-", read list from stdin)
+       list_of_files: list of files to count
+
+   Disclaimer:
+     It was easier to get string escaping and comment nesting right in C then
+     in Perl. It would be even easier in OCaml, but what the hell ;-)
+     Only sloc_count() functions is mine, rest of this file is copy of c_count.c.
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+/* Globals */
+long total_sloc;
+
+int peek(FILE *stream) {
+ int c = getc(stream);
+ ungetc(c, stream);
+ return c;
+}
+
+int ispeek(int c, FILE *stream) {
+ if (c == peek(stream)) {return 1;}
+ return 0;
+}
+
+long line_number;
+
+int getachar(FILE *stream) {
+/* Like getchar(), but keep track of line number. */
+ static int last_char_was_newline = 0;
+ int c;
+
+ c = getc(stream); 
+ if (last_char_was_newline) line_number++;
+ if (c == '\n') last_char_was_newline=1;
+ else           last_char_was_newline=0;
+ return c;
+}
+
+
+long sloc_count(char *filename, FILE *stream) {
+ /* Count the sloc in the program in stdin. */
+ long sloc = 0;
+
+ int sawchar = 0;                /* Did you see a character on this line? */
+ int c;
+ 
+ int comment_lev = 0;		/* Level of comment nesting. */
+ int in_string = 0;		/* 0 or 1 */
+ 
+
+ while ((c = getachar(stream)) != EOF) {
+   switch (c) {
+   case '"':
+     in_string = !in_string;
+     break;
+     
+   case '(':
+     if (!in_string && ispeek('*', stream)) {
+       comment_lev++;
+       getachar(stream);	/* skip '*' */
+     }
+     break;
+     
+   case '*':
+     if (comment_lev && !in_string && ispeek(')', stream)) {
+       comment_lev--;
+       getachar(stream);	/* skip ')' */
+       continue /* while */;
+     }
+     break;
+	 
+   case '\\':
+     /* Ignore next character if in string.  But don't ignore newlines. */
+     if (in_string && !ispeek('\n', stream))
+       getachar(stream);
+     break;
+   
+   case ' ':
+   case '\t':
+     /* just ignore blanks */
+     continue /* while */;
+   
+   case '\n':
+     if (sawchar) {
+       sloc++;
+       sawchar = 0;
+     }
+     continue /* while */;
+     
+   default:
+     break;
+   }
+
+   if (comment_lev == 0)
+     sawchar = 1;
+ }
+
+ /* We're done with the file.  Handle EOF-without-EOL. */
+ if (sawchar) sloc++;
+
+ if (comment_lev) {
+     fprintf(stderr, "ml_count ERROR - terminated in comment in %s\n", filename);
+ } else if (in_string) {
+     fprintf(stderr, "ml_count ERROR - terminated in string in %s\n", filename);
+ }
+
+ return sloc;
+}
+
+
+void count_file(char *filename) {
+  long sloc;
+  FILE *stream;
+
+  stream = fopen(filename, "r");
+  line_number = 1;
+  sloc = sloc_count(filename, stream);
+  total_sloc += sloc;
+  printf("%ld %s\n", sloc, filename);
+  fclose(stream);
+}
+
+char *read_a_line(FILE *file) {
+ /* Read a line in, and return a malloc'ed buffer with the line contents.
+    Any newline at the end is stripped.
+    If there's nothing left to read, returns NULL. */
+
+ /* We'll create a monstrously long buffer to make life easy for us: */
+ char buffer[10000];
+ char *returnval;
+ char *newlinepos;
+
+ returnval = fgets(buffer, sizeof(buffer), file);
+ if (returnval) {
+   newlinepos = buffer + strlen(buffer) - 1;
+   if (*newlinepos == '\n') {*newlinepos = '\0';};
+   return strdup(buffer);
+ } else {
+   return NULL;
+ }
+}
+
+
+int main(int argc, char *argv[]) {
+ long sloc;
+ int i;
+ FILE *file_list;
+ char *s;
+
+ total_sloc = 0;
+ line_number = 1;
+
+ if (argc <= 1) {
+   sloc = sloc_count("-", stdin);
+   printf("%ld %s\n", sloc, "-");
+   total_sloc += sloc;
+ } else if ((argc == 3) && (!strcmp(argv[1], "-f"))) {
+   if (!strcmp (argv[2], "-")) {
+     file_list = stdin;
+   } else {
+     file_list = fopen(argv[2], "r");
+   }
+   if (file_list) {
+     while ((s = read_a_line(file_list))) {
+       count_file(s);
+       free(s);
+     }
+   }
+ } else {
+   for (i=1; i < argc; i++) { count_file(argv[i]); }
+ }
+ printf("Total:\n");
+ printf("%ld\n", total_sloc);
+ return 0; /* Report success */
+}
+
Only in sloccount-2.21-: pascal_count
Only in sloccount-2.21-: php_count
diff -ur sloccount-2.21/sloccount.html sloccount-2.21-/sloccount.html
--- sloccount-2.21/sloccount.html	Wed Jan 29 04:12:56 2003
+++ sloccount-2.21-/sloccount.html	Sat Feb 15 21:53:37 2003
@@ -2065,7 +2065,7 @@
 Note that this does not use the counter as C/C++ internally, since
 it's quite legal in lex to have "//" (where it is NOT a comment).
 <li>LISP (.el, .scm, .lsp, .jl) [lisp]: Comments begin with ";".
-<li>ML (.ml, .mli) [ml]: Comments are enclosed in (* .. *).
+<li>ML (.ml, .mli, .mll, mly) [ml]: Comments nest and are enclosed in (* .. *).
 <li>Modula3 (.m3, .i3) [modula3]: Comments are enclosed in (* .. *).
 <li>Objective-C (.m) [objc]: Comments are old C-style /* .. */ comments.
 <li>Pascal (.p, .pas) [pascal]: Comments are enclosed in curly braces {}
